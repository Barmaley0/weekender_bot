---
name: Deploy Bot

on:
  push:
    branches: [main]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: ruff
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run Ruff linter
        run: ruff check .

  types:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: mypy
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install types-pytz
      - name: Run Mypy
        run: mypy --ignore-missing-imports --exclude migrations .

  deploy:
    runs-on: ubuntu-latest
    needs: [lint, types]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          sudo apt-get update && sudo apt-get install -y sshpass
          ssh-keyscan -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Verify SSH connection
        run: |
          if [[ -n "${{ secrets.SSH_KEY_PASSPHRASE }}" ]]; then
            sshpass -p "${{ secrets.SSH_KEY_PASSPHRASE }}" ssh -o BatchMode=yes \
                -p ${{ secrets.SSH_PORT }} \
                -i ~/.ssh/id_ed25519 \
                ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "echo 'SSH connection successful'"
          else
            ssh -o BatchMode=yes \
                -p ${{ secrets.SSH_PORT }} \
                -i ~/.ssh/id_ed25519 \
                ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "echo 'SSH connection successful'"
          fi || {
            echo "::error::SSH connection failed"
            echo "Debug info:"
            echo "1. Проверьте формат SSH_PRIVATE_KEY в Secrets"
            echo "2. Проверьте SSH_KEY_PASSPHRASE (если ключ защищён)"
            echo "3. Проверьте содержимое ~/.ssh/authorized_keys на сервере"
            echo "4. Проверьте логи на сервере: sudo tail -f /var/log/auth.log"
            exit 1
          }

      - name: Deploy application
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
        run: |
          if [[ -n "${{ secrets.SSH_KEY_PASSPHRASE }}" ]]; then
            sshpass -p "${{ secrets.SSH_KEY_PASSPHRASE }}" ssh -T \
                -p ${{ secrets.SSH_PORT }} \
                -i ~/.ssh/id_ed25519 \
                ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
          else
            ssh -T -p ${{ secrets.SSH_PORT }} \
                -i ~/.ssh/id_ed25519 \
                ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
          fi
          set -euo pipefail

          # Verify environment
          if [[ -z "$BOT_TOKEN" || -z "$POSTGRES_PASSWORD" || -z "$POSTGRES_DB" ]]; then
            echo "Error: BOT_TOKEN, POSTGRES_PASSWORD or POSTGRES_DB is empty!"; exit 1
          fi

          echo "Starting deployment process..."
          cd ~/weekender_bot || { echo "Failed to cd into weekender_bot directory"; exit 1; }

          # Verify git repository state
          if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
            echo "Not a git repository"
            exit 1
          fi

          # Update code
          echo "Updating code from repository..."
          git fetch --all
          git reset --hard origin/main

          # Update .env variables (preserve existing ones)
          echo "Updating .env file..."
          grep -v "BOT_TOKEN=" .env > .env.tmp || true
          grep -v "POSTGRES_USER=" .env.tmp > .env || true
          grep -v "POSTGRES_PASSWORD=" .env > .env.tmp || true
          grep -v "POSTGRES_DB=" .env.tmp > .env || true
          grep -v "DATABASE_URL=" .env > .env.tmp || true
          mv .env.tmp .env

          echo "BOT_TOKEN=$BOT_TOKEN" >> .env
          echo "POSTGRES_DB=$POSTGRES_DB" >> .env
          echo "POSTGRES_USER=$POSTGRES_USER" >> .env
          echo "POSTGRES_PASSWORD=$POSTGRES_PASSWORD" >> .env
          echo "DATABASE_URL=postgresql+asyncpg://$POSTGRES_USER:$POSTGRES_PASSWORD@db:5432/$POSTGRES_DB" >> .env

          # Rebuild and restart only the bot
          echo "Rebuilding bot container..."
          docker-compose build --no-cache bot
          docker-compose up -d --force-recreate bot

          # Apply migrations
          docker-compose exec bot alembic upgrade head 2>&1 | tee alembic.log || {
            echo "❌ Alembic migration failed. Logs:"
            cat alembic.log
            exit 1
          }

          # Verify deployment
          echo "Checking services..."
          docker-compose ps | grep bot
          docker-compose logs bot --tail=20

          echo "✅ Deployment successful!"
          EOF
